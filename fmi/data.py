# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_data.ipynb (unless otherwise specified).

__all__ = ['dicomsplit', 'check_duplicate', 'dicom_splitter']

# Cell
from fastai.vision.all import *
from fastai.medical.imaging import *

# Cell
def dicomsplit(valid_pct=0.2, seed=None, **kwargs):
    "Splits `items` between train/val with `valid_pct`"
    "and checks if identical patient IDs exist in both the train and valid sets"
    def _inner(o, **kwargs):
        train_list=[]; valid_list=[]
        if seed is not None: torch.manual_seed(seed)
        rand_idx = L(int(i) for i in torch.randperm(len(o)))
        cut = int(valid_pct * len(o))
        trn = rand_idx[cut:]; trn_p = o[rand_idx[cut:]]
        val = rand_idx[:cut]; val_p = o[rand_idx[:cut]]

        for i, im in enumerate(trn_p):
            trn = im.dcmread()
            patient_ID = trn.PatientID
            train_list.append(patient_ID)
        for j, jm in enumerate(val_p):
            val = jm.dcmread()
            vpatient_ID = val.PatientID
            valid_list.append(vpatient_ID)
        print(f'Duplicate: {set(train_list) & set(valid_list)}')
        return rand_idx[cut:], rand_idx[:cut]
    return _inner

# Cell
def check_duplicate(items, seed=5):
    trn, val = DicomSplit(valid_pct=0.2, seed=seed)(items)
    return trn, val

# Cell
def dicom_splitter(items, valid_pct=0.2):
    trn, val = DicomSplit(valid_pct=valid_pct)(items)
    valid_idx = val
    def _inner(o):
        train_idx = np.setdiff1d(np.array(range_of(o)), np.array(valid_idx))
        print(f'train:{train_idx} val:{valid_idx}')
        return L(train_idx, use_list=True), L(valid_idx, use_list=True)
    return _inner