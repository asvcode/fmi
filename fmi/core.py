# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['instance_sort', 'instance_dcmread', 'instance_show', 'get_dicom_image', 'mask_and_save',
           'dicom_convert_3channel']

# Cell
from fastai.vision.all import *
from fastai.medical.imaging import *
from torchvision.utils import save_image

# Cell
def instance_sort(folder:(Path, L)):
    "sort files by instance number"
    if isinstance(folder, Path): folder = get_dicom_files(folder)
    if isinstance(folder, L): folder = folder
    sorted_files = []
    for file in folder:
        instance = dcmread(file)[0x20, 0x13].value
        sorted_files.append([instance, file])
    return L(sorted(sorted_files))

# Cell
def instance_dcmread(folder:(L)):
    "instance dcmread"
    file = [dcmread(o[1]) for o in folder]
    return file

# Cell
def instance_show(folder: (L), nrows=1):
    "show sorted files"
    f_list = []
    for file in instance_sort(folder):
        f = TensorDicom(dcmread(file[1]).pixel_array)
        f_list.append(f)
    return show_images(f_list, nrows=nrows)

# Cell
def get_dicom_image(df, key, nrows=3, source=None):
    imgs=[]
    title=[]
    for i in df.index:
        file_path = f"{source}/{df.iloc[i]['PatientID']}/{df.iloc[i]['InstanceNumber']}.dcm"
        dcc = dcmread(file_path).pixel_array
        imgs.append(dcc)
        pct = df.iloc[i][key]
        title.append(pct)
    return show_images(imgs, titles=title, nrows=nrows)

# Cell
def mask_and_save(df, source=None, show=None, window=dicom_windows.lungs, sigma:float=0.1, thresh:float=0.9, save=False, save_path=None):
    image_list = []
    for i in df.index:
        file_path = f"{source}/{df.iloc[i]['PatientID']}/{df.iloc[i]['InstanceNumber']}.dcm"
        file_name = df.iloc[i]['InstanceNumber']
        dcm = dcmread(file_path)
        wind = dcm.windowed(*window)
        mask = dcm.mask_from_blur(window, sigma=sigma, thresh=thresh, remove_max=False)
        bbs = mask2bbox(mask)
        lo,hi = bbs
        imh = wind[lo[0]:hi[0],lo[1]:hi[1]]
        if save is not False:
            save_image(imh, f'{save_path}/{file_name}.png')
        else:
            pass
        image_list.append(imh)
    if show is not None:
        show_images(image_list[:10], nrows=1)

# Cell
@patch
def updated_dict(self:DcmDataset, windows=[dicom_windows.lungs]):
    pxdata = (0x7fe0,0x0010)
    vals = [self[o] for o in self.keys() if o != pxdata]
    its = [(v.keyword, v.value) for v in vals]
    res = dict(its)

    stats = 'min', 'max', 'mean', 'std'
    pxs = self.pixel_array
    for f in stats: res['img_'+f] = getattr(pxs, f)()
    res['img_pct_window'] = self.pct_in_window(*windows)
    res['file_path'] = f'{self.PatientID}/{self.InstanceNumber}.dcm'
    return res

# Cell
def _dcm2dict2(fn, windows, **kwargs): return fn.dcmread().updated_dict(windows, **kwargs)

# Cell
@delegates(parallel)
def _from_dicoms2(cls, fns, n_workers=0, **kwargs):
    return pd.DataFrame(parallel(_dcm2dict2, fns, n_workers=n_workers, **kwargs))
pd.DataFrame.from_dicoms2 = classmethod(_from_dicoms2)

# Cell
def dicom_convert_3channel(fn:(Path,str), save_dir:(str), win1=dicom_windows.lungs, \
                           win2=dicom_windows.liver, win3=dicom_windows.brain):
    "Split a dicom image into 3 windows with each window per channel and saved as jpg"
    data = dcmread(fn)
    file_name = str(fn); name = file_name.split('\\')[-1].split('.')[0]

    chan_one = np.expand_dims(data.windowed(*win1), axis=2)
    chan_two = np.expand_dims(data.windowed(*win2), axis=2)
    chan_three = np.expand_dims(data.windowed(*(win3)), axis=2)
    image = np.concatenate([chan_one, chan_two, chan_three], axis=2)
    ten_image = TensorImage(image).permute(2,0,1)
    save_image(ten_image, f'{save_dir}/{name}.jpg')